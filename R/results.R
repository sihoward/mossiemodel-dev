#' Population size time series
#'
#' Plot time series of population size using model outputs.
#'
#' @param resdf Results dataframe generated by mosqmod::runModel().
#' @param selectPopn Character vector of population component to plot (options are "L", "L_1", "L_2", "L_3", "L_4", "L_5" or "M").
#' @param include_temp Include a plot facet of temperature time series (default = TRUE).
#'
#' @importFrom rlang .data
#' @return
#' @export
plot_popn <- function(resdf,
                      selectPopn = c("L", "L_1", "L_2", "L_3", "L_4", "L_5", "M"),
                      include_temp = TRUE){

  if(include_temp){
    selectPopn <- c(selectPopn, "Tmean")
  }

  # append last recorded temperature (removes gap when drawing geom_line)
  if(any(resdf$source != "projected")){
    last.recorded <- resdf[max(which(resdf$source != "projected")),]
    last.recorded$source <- "projected"
    resdf <- rbind(resdf, last.recorded)
  }

  # stack selected columns
  d <- tidyr::pivot_longer(resdf, cols = dplyr::all_of(selectPopn))
  # respect plotting order of selectPopn
  d$name <- factor(d$name, levels = unique(d$name))
  # create factor for recorded vs projected temperature estimates
  d$Temperature <- factor(ifelse(d$source %in% "projected", "projected", "recorded"),
                          levels = c("recorded", "projected"))

  # rescale y-axis values for population sizes
  ## rows with population sizes
  popnRows <- !d$name %in% "Tmean"
  ## get max value
  maxval <- max(d$value[popnRows])
  ## potential y scale denominators
  yscale <- c(1, 100,1000,10000, 100000, 1000000, 10000000)
  ## pick denominator closest to population sizes
  ind <- (maxval - yscale > 0) & (maxval - yscale) == min(maxval - yscale[maxval - yscale > 0])
  ## divide values by denominator
  d$value[popnRows] <- d$value[popnRows] / yscale[ind]
  ## scale label
  if(yscale[ind] > 1){
    ylab_scaled <- paste0("Population size\n(", format(yscale[ind], scientific = FALSE), "s per square km)")
  } else {
    ylab_scaled <- paste0("Population size\n(number per square km)")
  }


  gg <-
    ggplot2::ggplot(d, ggplot2::aes(y = .data$value, x = .data$Date,
                                    color = .data$name, size = .data$Temperature)) +
    ggplot2::geom_line() +
    ggplot2::scale_color_discrete(name = "Population",
                         labels = function(x) c(L = "Larvae", M = "Adults", Tmean = "Temperature")[x],
                         guide = ggplot2::guide_legend(order = 1)) +
    ggplot2::scale_size_manual(breaks = c("recorded", "projected"), values = c(1.2,0.5),
                               guide = ggplot2::guide_legend(order = 2))


  if(!include_temp){
    gg <- gg + ggplot2::labs(y = ylab_scaled)
  } else {
    gg <- gg + ggplot2::facet_grid(name == "Tmean" ~ . , scale = "free_y",
                                   labeller = ggplot2::as_labeller(c('TRUE' = "Temperature\n(degrees C)",
                                                                     'FALSE' = ylab_scaled)),
                                   switch = "y") +
      ggplot2::labs(y = NULL)
  }

  # format x breaks and labels
  gg <-
    gg + ggplot2::scale_x_date(date_breaks = "6 months",
                               date_minor_breaks = "1 month",
                               label = function(x) format(x, "%b %Y"))

  return(gg)
}


#' Population size time series overlay
#'
#' Population size time series of model outputs with years overlaid.
#'
#' @param resdf Results dataframe generated by mosqmod::runModel().
#' @param selectPopn Character vector of population component to plot (options are "L", "L_1", "L_2", "L_3", "L_4", "L_5" or "M").
#'
#' @importFrom rlang .data
#' @return
#' @export
#'
#' @examples
plot_popn_years <- function(resdf,
                       selectPopn = c("L", "L_1", "L_2", "L_3", "L_4", "L_5", "M")){

  # append last recorded temperature (removes gap when drawing geom_line)
  if(any(resdf$source != "projected")){
    last.recorded <- resdf[max(which(resdf$source != "projected")),]
    last.recorded$source <- "projected"
    resdf <- rbind(resdf, last.recorded)
  }

  # stack selected columns
  d <- tidyr::pivot_longer(resdf, cols = dplyr::all_of(selectPopn))
  # respect plotting order of selectPopn
  d$name <- factor(d$name, levels = unique(d$name))
  # calendar year
  d$Year <- as.numeric(format(d$Date, "%Y"))
  # Start years in July
  d$Year <- d$Year - (as.numeric(format(d$Date, "%m")) < 7)
  # drop any leap days
  d <- d[!grepl("02-29", format(d$Date, "%m-%d")),]
  # align start of each year with first date in sequence
  d <- dplyr::mutate(dplyr::group_by(d, .data$Year),
                     Date = min(d$Date) + (.data$Date - min(.data$Date)))
  # make year discrete
  d$Year <- factor(d$Year, levels = sort(unique(d$Year), decreasing = TRUE))
  # create factor for recorded vs projected temperature estimates
  d$Temperature <- factor(ifelse(d$source %in% "projected", "projected", "recorded"),
                          levels = c("recorded", "projected"))

  # rescale y-axis values for population sizes
  ## get max value
  maxval <- max(d$value)
  ## potential y scale denominators
  yscale <- c(1, 100,1000,10000, 100000, 1000000, 10000000)
  ## pick denominator closest to population sizes
  ind <- (maxval - yscale > 0) & (maxval - yscale) == min(maxval - yscale[maxval - yscale > 0])
  ## divide values by denominator
  d$value <- d$value / yscale[ind]
  ## scale label
  if(yscale[ind] > 1){
    ylab_scaled <- paste0("Population size\n(", format(yscale[ind], scientific = FALSE), "s per square km)")
  } else {
    ylab_scaled <- paste0("Population size\n(number per square km)")
  }


  gg <- ggplot2::ggplot(d, ggplot2::aes(y = .data$value, x = .data$Date,
                                        color = .data$Year, group = .data$Year,
                                        size = .data$Temperature)) +
    ggplot2::geom_line() +
    ggplot2::labs(y = ylab_scaled) +
    ggplot2::scale_x_date(breaks = seq(min(d$Date), by = "3 month", length.out = 5),
                          date_minor_breaks = "1 month",
                          date_label = "%b") +
    ggplot2::scale_color_brewer(palette = "Dark2") +
    ggplot2::scale_size_manual(breaks = c("recorded", "projected"), values = c(1.2,0.5))

  if(length(selectPopn) > 1){
    gg <- gg + ggplot2::facet_wrap(~name, scales = "free_y")
  }

  return(gg)
}
